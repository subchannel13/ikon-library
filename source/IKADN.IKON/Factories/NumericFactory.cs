// Copyright © 2019 Ivan Kravarščan. All rights reserved. Licensed under the 
// LGPL License. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text.RegularExpressions;

using Ikadn.Ikon.Types;

namespace Ikadn.Ikon.Factories
{
	/// <summary>
	/// IKADN object factory for IKON numeric objects.
	/// </summary>
	public class NumericFactory : IIkadnObjectFactory
	{
		/// <summary>
		/// Sign for IKADN numeric object.
		/// </summary>
		public static readonly char OpeningSign = '=';

        /// <summary>
        /// Number format used for IKON numeric objects.
        /// </summary>
        public static readonly IFormatProvider NumberFormat = NumberFormatInfo.InvariantInfo;

        /// <summary>
        /// Valid styles for IKON numeric objects.
        /// </summary>
        public static readonly NumberStyles NumberStyle = NumberStyles.Float;

		/// <summary>
		/// Sign for IKADN numeric object.
		/// </summary>
		public char Sign
		{
			get { return OpeningSign; }
		}

		/// <summary>
		/// Parses input for a IKADN object.
		/// </summary>
		/// <param name="reader">IKADN parser instance.</param>
		/// <returns>IKADN object generated by factory.</returns>
		public IkadnBaseObject Parse(IkadnReader reader)
		{
			if (reader == null)
				throw new ArgumentNullException("reader");

			reader.SkipWhiteSpaces();
			if (!reader.HasNext)
				throw new EndOfStreamException("Trying to read beyond the end of stream. Last read character was at " + reader.PositionDescription + ".");

			string startPosition = reader.PositionDescription;
			string numberText = reader.ReadWhile(ValidChars).Trim();
			if (numberText.Length == 0)
				throw new FormatException("Unexpected character at " + reader.PositionDescription + ", while reading IKON numeric value");

			if (numberText == IkonFloat.PositiveInfinity)
				return new IkonFloat(double.PositiveInfinity);
			
			if (numberText == IkonFloat.NegativeInfinity)
				return new IkonFloat(double.NegativeInfinity);
			
			if (numberText == IkonFloat.NotANumber)
				return new IkonFloat(double.NaN);
			
			if (!NumberMatcher.IsMatch(numberText))
				throw new FormatException("Characters from " + startPosition + " to " + reader.PositionDescription + " couldn't be parsed as IKON numeric value");

			if (long.TryParse(numberText, NumberStyle, NumberFormat, out long tempI))
				return new IkonInteger(tempI);

			if (decimal.TryParse(numberText, NumberStyle, NumberFormat, out decimal tempD))
				return new IkonDecimal(tempD);

			if (double.TryParse(numberText, NumberStyle, NumberFormat, out double tempF))
				return new IkonFloat(tempF);

			throw new FormatException("Characters from " + startPosition + " to " + reader.PositionDescription + " couldn't be parsed as IKON numeric value (possibly value too big)");
		}

		private static readonly ICollection<char> ValidChars = new HashSet<char>(defineValidChars());
		private static readonly Regex NumberMatcher = new Regex("[\\+\\-]?[0-9\\.eE]+", RegexOptions.Compiled | RegexOptions.CultureInvariant);

		private static IEnumerable<char> defineValidChars()
		{
			yield return '-';
			yield return '.';

			for (char c = 'a'; c <= 'z'; c++) yield return c;
			for (char c = 'A'; c <= 'Z'; c++) yield return c;
			for (char c = '0'; c <= '9'; c++) yield return c;
		}
	}
}
