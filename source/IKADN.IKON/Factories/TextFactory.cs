// Copyright © 2019 Ivan Kravarščan. All rights reserved. Licensed under the 
// BSD 3-Clause License. See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.IO;

using Ikadn.Ikon.Types;
using Ikadn.Utilities;

namespace Ikadn.Ikon.Factories
{
	/// <summary>
	/// IKADN object factory for IKON  textual objects from backslash escaped
	/// format.
	/// </summary>
	public class TextFactory : IIkadnObjectFactory
	{
		/// <summary>
		/// Sign for IKADN textual object (backslash escaped format).
		/// </summary>
		public static readonly char OpeningSign = '"';

		/// <summary>
		/// Closing character for IKON textual object in textual
		/// representation (backslash escaped format).
		/// </summary>
		public static readonly char ClosingChar = '"';

		private const char EscapeChar = '\\';
		private const char Unicode16Char = 'u';
		private const char Unicode32Char = 'U';

		private static readonly Dictionary<char, char> EscapeCodes = defineEscapeCodes();

		/// <summary>
		/// Sign for IKADN textual object (backslash escaped format).
		/// </summary>
		public char Sign
		{
			get { return OpeningSign; }
		}

		/// <summary>
		/// Parses input for a IKADN object.
		/// </summary>
		/// <param name="reader">IKADN reader instance.</param>
		/// <returns>IKADN value generated by factory.</returns>
		public IkadnBaseObject Parse(IkadnReader reader)
		{
			if (reader == null)
				throw new System.ArgumentNullException("reader");

			bool escaping = false;
			int unicodeDigits = 0;
			long unicodeChar = 0;
			string text = reader.ReadConditionally(nextChar =>
			{
				char c = (char)nextChar;

				if (unicodeDigits > 0)
				{
					unicodeChar *= 16;
					try
					{
						unicodeChar += Convert.ToInt32(c.ToString(), 16);
					}
					catch (FormatException)
					{
						throw new FormatException("Unexpected character after " + reader.PositionDescription + " while reading unicode character number for IKON textual data.");
					}
					unicodeDigits--;

					ReadingDecision decision;
					if (unicodeDigits % 4 == 0)
					{
						decision = new ReadingDecision((char)unicodeChar, CharacterAction.Substitute);
						unicodeChar = 0;
					}
					else
						decision = new ReadingDecision(c, CharacterAction.Skip);

					escaping = unicodeDigits > 0;
					return decision;
				}

				if (escaping)
				{
					if (EscapeCodes.ContainsKey(c))
					{
						escaping = false;
						return new ReadingDecision(EscapeCodes[c], CharacterAction.Substitute);
					}
					else if (c == Unicode16Char)
					{
						unicodeDigits = 4;
						unicodeChar = 0;
						return new ReadingDecision(c, CharacterAction.Skip);
					}
					else if (c == Unicode32Char)
					{
						unicodeDigits = 8;
						unicodeChar = 0;
						return new ReadingDecision(c, CharacterAction.Skip);
					}
					else
						throw new FormatException("Unsupported string escape sequence: \\" + nextChar);

				}
				if (nextChar == EscapeChar)
				{
					escaping = true;
					return new ReadingDecision(c, CharacterAction.Skip);
				}
				else if (nextChar == ClosingChar)
					return new ReadingDecision(c, CharacterAction.Stop);
				else
					return new ReadingDecision(c, CharacterAction.AcceptAsIs);
			});

			if (reader.Peek() != ClosingChar)
				throw new EndOfStreamException("Unexpected end of stream at " + reader.PositionDescription + " while reading IKON textual data.");
			reader.Read();

			return new IkonText(text);
		}

		private static Dictionary<char, char> defineEscapeCodes()
		{
			return new Dictionary<char, char>
			{
				{ '\\', '\\' },
				{ '"', '"' },
				{ 'n', '\n' },
				{ 'r', '\r' },
				{ 't', '\t' }
			};
		}
	}
}
