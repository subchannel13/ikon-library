// Copyright © 2019 Ivan Kravarščan. All rights reserved. Licensed under the 
// BSD 3-Clause License. See License.txt in the project root for license information.

using System;
using System.Text;
using Ikadn.Ikon.Types;

namespace Ikadn.Ikon.Factories
{
	/// <summary>
	/// IKADN object factory for IKON  textual objects from text block format.
	/// </summary>
	public class TextBlockFactory : IIkadnObjectFactory
	{
		/// <summary>
		/// Sign for IKADN textual object (block format).
		/// </summary>
		public static readonly char OpeningSign = '§';
		
		/// <summary>
		/// Closing character for IKON textual object in textual
		/// representation (block format).
		/// </summary>
		public static readonly char ClosingChar = '\\';
		
		/// <summary>
		/// Sign for IKADN textual object (block format).
		/// </summary>
		public char Sign {
			get {
				return OpeningSign;
			}
		}

		/// <summary>
		/// Parses input for a IKADN object.
		/// </summary>
		/// <param name="reader">IKADN reader instance.</param>
		/// <returns>IKADN value generated by factory.</returns>
		public IkadnBaseObject Parse(IkadnReader reader)
		{
            if (reader == null)
                throw new ArgumentNullException("reader");

            var text = new StringBuilder();
			string textIndent =
				reader.LineIndentation + 
				readIndentSpec(reader.ReadUntil('\n','\r').Trim());
			
			skipEndOfLine(reader);
			
			while(checkIndentation(reader, textIndent)) {
				text.AppendLine(reader.ReadUntil('\n','\r'));
				skipEndOfLine(reader);
			}
			
			if (text.Length >= Environment.NewLine.Length)
				text.Length -= Environment.NewLine.Length;
			
			return new IkonText(text.ToString());
		}

        private static bool checkIndentation(IkadnReader reader, string indentation)
		{
			foreach(char expectedSpace in indentation)
				if (reader.Peek() == expectedSpace)
					reader.Read();
				else
					if (reader.Peek() == ClosingChar) {
						reader.Read();
						return false;
					}
					else
						throw new FormatException("Unexpected character at " + reader.PositionDescription + ", expected block closing character or block content indentation.");
			
			return true;
		}

        private static void skipEndOfLine(IkadnReader reader)
		{
			char nextChar = reader.Peek();
			
			if (nextChar == '\r') {
				reader.Read();
				nextChar = reader.Peek();
			}
			
			if (nextChar != '\n')
				throw new FormatException("No or unknown type of line ending method at " + reader.PositionDescription);
			
			reader.Read();
		}
		
		private static string readIndentSpec(string indentSpec)
		{
			if (string.IsNullOrEmpty(indentSpec))
				return "\t";
			
			return indentSpec.Replace("\\t", "\t").Replace("\\s", " ");
		}
	}
}
